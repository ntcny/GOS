%!TEX root = ../report.tex"
\section{Вопрос 51: Схемы цифровой подписи Фиата-Шамира, Эль-Гамаля и Шнорра.}

\zagolovok{Протокол Фиата-Шамира}

В протоколе Фиата-Шамира (Amos Fiat, Adi Shamir) третье лицо, которому доверяют, выбирает два больших простых числа p и q, чтобы вычислить значение $n = p * q$. Значение n объявляется общедоступным. Значения p и q сохраняются секретными. Алиса, претендент, выбирает секретное число s между 1 и n - 1. Она вычисляет: $v = s^{2}mod n$. Она сохраняет s как свой секретный ключ и регистрирует v как свой общедоступный ключ вместе с третьим лицом. Проверка Алисы Бобом может быть сделана в четыре шага.

1). Алиса- претендент выбирает случайное число r между 0, и n - 1 ( r называется "обязательство"). Она затем вычисляет значение $x = r^{2}mod n$ ( x называется "свидетельство").

2). Алиса передает x Бобу как свидетельство.

3).Боб-верификатор передает вызов c Алисе. Значение c равно или 0, или 1.

4). Алиса вычисляет свой ответ $y = rs^{c}$. Обратите внимание, что r - случайное число, выбранное Алисой на первом шаге, s - ее секретный ключ и c - признак ( 0 или 1 ).

5). Алиса передает ответ Бобу, чтобы показать, что она знает значение своего секретного ключа, s. Она подтверждает, что это была именно Алиса.

6). Боб вычисляет $y^{2}$ и $x^{c}$. Если эти два значения являются конгруэнтными, то для Алисы значение s означает "она честна"; или она вычислила значение y другим способом ("она нечестная"), потому что мы можем легко доказать, что y - тот же самый, как $x^{c}$ по модулю n:  $ y^{2} = (rs^{c})^2 = r^{2}s^{2c} = r^{2}(s^2)^{c} = x^{c}$

\zagolovok {Схемы цифровой подписи  Эль-Гамаля} 

Рассмотрим подробнее алгоритм цифровой подписи Эль-Гамаля. Для того чтобы генерировать пару ключей (открытый ключ - секретный ключ), сначала выбирают некоторое большое простое целое число Р и большое целое число G, причем G < Р. Отправитель и получатель подписанного документа используют при вычислениях одинаковые большие целые числа Р  и G , которые не являются секретными.

Отправитель выбирает случайное целое число $X, 1 < Х \leq (Р-1)$, и вычисляет: $Y = G^{X} mod P$.

Число Y является открытым ключом, используемым для проверки подписи отправителя. Число Y открыто передается всем потенциальным получателям документов.
Число Х является секретным ключом отправителя для подписывания документов и должно храниться в секрете.
Для того чтобы подписать сообщение М, сначала отправитель хэширует его с помощью хэш-функции $h(*)$ в целое число m: $m = h(М), 1 < m < (Р-1)$

и генерирует случайное целое число $К, 1 < К < (Р-1)$, такое, что К и (Р-1) являются взаимно простыми. Затем отправитель вычисляет целое число а: $a = G^{K} mod P$ 

и, применяя расширенный алгоритм Евклида, вычисляет с помощью секретного ключа Х целое число b из уравнения $ m = Х * а + К * b (mod (Р-1))$. 

Пара чисел (а,b) образует цифровую подпись S: S=(а,b) ,проставляемую под документом М.

Тройка чисел (М,а,b) передается получателю, в то время как пара чисел (Х,К) держится в секрете.
После приема подписанного сообщения (М,а,b) получатель должен проверить, соответствует ли подпись S=(а,b) сообщению М. Для этого получатель сначала вычисляет по принятому сообщению М число m = h(М), т.е. хэширует принятое сообщение М.

Затем получатель вычисляет значение $A = Y^{a} a^{b} (mod P)$ и признает сообщение М подлинным, только если $A = G^{m} (mod P)$. 

Иначе говоря, получатель проверяет справедливость соотношения: $Y^{a} a^{b}(mod P) = G^m (mod P) $.


\zagolovok {Схемы цифровой подписи  Шнорра}

 Отправитель и получатель электронного документа используют при вычислении большие целые числа: G и Р - простые числа, L бит каждое $(512 \leq L \leq 1024)$; q - простое число длиной 160 бит (делитель числа (Р-1)). Числа G, Р, q являются открытыми и могут быть общими для всех пользователей сети.

Отправитель выбирает случайное целое число X, 1 < Х < q. Число Х является секретным ключом отправителя для формирования электронной цифровой подписи.

Затем отправитель вычисляет значение: $Y = G^{X} mod P$.

Число Y является открытым ключом для проверки подписи отправителя и передается всем получателям документов. Этот алгоритм также предусматривает использование односторонней функции хэширования h(·). В стандарте DSS определен алгоритм безопасного хэширования SНА (Secure Hash Algorithm). Для того чтобы подписать документ М, отправитель хэширует его в целое хэш-значение m: $ m = h(M), 1<m<q$, затем генерирует случайное целое число К, 1< К< q, и вычисляет число r: $r = (G^K mad P) mod q$.

Затем отправитель вычисляет с помощью секретного ключа Х целое число s: $s = ((m+r*X)/K) mod q$. 

Пара чисел (r,s) образует цифровую подпись $S = (r.s)$